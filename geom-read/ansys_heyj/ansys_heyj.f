ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc This is the new version software to read meshgeom generated by ansys     ccc
cc First written by pengzhen,rewrite by yangminglin at 2010.1.9.            ccc
cc 1.Norm direction of elements on face is changed                          ccc
cc 2.Array is allocatable,bigger problem can be solved                      ccc
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      implicit none
      integer mvoladj,nnode,maxnode,mvolele,mvoledge,maxedge
      integer npatch,klv,tlv(9)
      parameter( mvoladj=30)

      real,allocatable:: xyz(:,:), xyzs(:,:), xyzv(:,:), 
     &          xyzc1(:, :), xyzc2(:,:)
      integer,allocatable::ipat(:,:), iedge(:,:)
      integer,allocatable::ln(:,:),lp(:,:), lds(:,:)
      integer,allocatable::lv(:,:), le(:,:), lnc(:,:), 
     &          lpc(:,:), ldv(:,:)
      integer,allocatable::iq(:),ip(:), ipin(:), nc(:)
      integer,allocatable::ipposi(:),iqposi(:)
      integer,allocatable::iqof(:),iqfo(:),
     &          iqof1(:),iqfo1(:)
      real,allocatable::   rp(:), rp1(:)
      integer,allocatable:: ipw1(:), ipw2(:), ipw3(:),
     &          ipw4(:),lef(:,:)
      integer,allocatable::ipele(:,:)
      integer iargc,nargs,charlength
      character*256 tailname,scomb,runnamet,runname,path
      integer k1,k2,i,j
      real d1,d2,d3,d
      integer nsnode, nvnode, nedge,ncnode, ncele, ncedge, nbnd
      integer ke, kec, keb, kei,mvolstore, msurstore,klc
      integer kefemabc, kefemsrc
      integer npecpat,mpecedge,jedgen 
      integer,allocatable::pecpat(:,:),pecjudge(:)
      integer,allocatable::jedgeco(:,:),jejudge(:)
      real   sf
      integer labelabc,labelsrc
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      nargs=iargc()
      if(nargs.ne.1) then
         write(*,*)" USAGE: *.exe [filename] "
         write(*,*)" For example(Windows): "
         write(*,*)" a.exe sph0 "
         write(*,*)" For example(Linux): "
         write(*,*)" a.x sph0 "
         stop
      endif
!      print*,"please input the scale factor:"
!      read(*,*),sf
      sf=1.0

      call getarg( 1, runname)

      tailname = '.xyz'
      call fstrcat (runname, tailname, scomb)
      open (1, file = scomb, status = 'unknown')
      tailname = '.ipat'
      call fstrcat (runname, tailname, scomb)
      open (2, file = scomb, status = 'unknown')
      tailname = '.lv'
      call fstrcat (runname, tailname, scomb)
      open (3, file = scomb, status = 'unknown')
      tailname = '.para_inp1'
      call fstrcat (runname, tailname, scomb)
      open (99, file = scomb, status = 'unknown')
c      tailname = '.metis'
c      call fstrcat (runname, tailname, scomb)
c      open (15, file = scomb, status = 'unknown')

      tailname = '.face'
      call fstrcat (runname, tailname, scomb)
      open (11, file = scomb, status = 'unknown')
      tailname = '.edge'
      call fstrcat (runname, tailname, scomb)
      open (12, file = scomb, status = 'unknown')

      tailname = '.fem'
      call fstrcat (runname, tailname, scomb)
      open (13, file = scomb, status = 'unknown')
      tailname = '.fmm_max'
      call fstrcat (runname, tailname, scomb)
      open (14, file = scomb, status = 'unknown')
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
ccc        read coordinate of all nodes into xyz
ccc nnode is the all number of nodes in volume and surface 
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      read(99,*)
      read(99,*) labelabc
      read(99,*)
      read(99,*) labelsrc

      read(1,*) nnode
      allocate(xyz(3,nnode))
      allocate(xyzs(3,nnode))
      allocate(xyzv(3,nnode))
      allocate(xyzc1(3,nnode))
      allocate(xyzc2(3,nnode))
      do i=1,nnode
      do j=1,3
         xyz(j,i)=0
         xyzs(j,i)=0
         xyzv(j,i)=0
         xyzc1(j,i)=0
         xyzc2(j,i)=0
      enddo
      enddo
      do i=1, nnode
         read(1,*) (xyz(j,i),j=1,3)
      enddo
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc read three nodes global number of each facepatch
cc                maxedge is 3*npatch
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc        
      read(2,*) npatch
      maxedge=3*npatch
      allocate(iedge(5,maxedge))
      allocate(ldv(2,maxedge))
      allocate(lds(2,maxedge))
      allocate(lef(3,npatch))
      do i=1,npatch
      do j=1,3
         lef(j,i)=0
      enddo
      enddo
      do i=1,maxedge
      do j=1,5
         iedge(j,i)=0
      enddo
      do j=1,2
         ldv(j,i)=0
         lds(j,i)=0
      enddo
      enddo
      allocate(ipat(4,npatch))
      allocate(ln(3,npatch))
      allocate(lp(3,npatch))
      allocate(lnc(4,npatch))
      allocate(lpc(3,npatch))
      allocate(nc(3*npatch))
      do i=1,npatch
      do j=1,4
         ipat(j,i)=0
         lnc(j,i)=0
      enddo
      do j=1,3
         ln(j,i)=0
         lp(j,i)=0
         lpc(j,i)=0
      enddo
      enddo
      do i=1,3*npatch
         nc(i)=0
      enddo
      do i=1,npatch
         read(2,*) (ipat(j,i),j=1,4)
      enddo
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc   read four nodes global number of each tetrahedron
cc     mvoledge is the maximum of 3*npatch and 6*klv
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      read(3,*) klv
      mvoledge=6*klv
      if(maxedge.gt.mvoledge)then
      mvoledge=maxedge
      else
      endif
      allocate(iq(mvoledge))
      allocate(ip(mvoledge))
      allocate(ipin(mvoledge))
      allocate(iqof(mvoledge))
      allocate(iqfo(mvoledge))
      allocate(iqof1(mvoledge))
      allocate(iqfo1(mvoledge))
      allocate(rp(mvoledge))
      allocate(rp1(mvoledge))
      allocate(ipw1(mvoledge))
      allocate(ipw2(mvoledge))
      allocate(ipw3(mvoledge))
      allocate(ipw4(mvoledge))
      do i=1,mvoledge
         iq(i)=0
         ip(i)=0
         ipin(i)=0
         iqof(i)=0
         iqfo(i)=0
         iqof1(i)=0
         iqfo1(i)=0
         rp(i)=0
         rp1(i)=0
         ipw1(i)=0
         ipw2(i)=0
         ipw3(i)=0
         ipw4(i)=0
      enddo
      allocate(ipele(mvoladj,mvoledge))
      do i=1,mvoledge
      do j=1,mvoladj
         ipele(j,i)=0
      enddo
      enddo
      allocate(lv(9,klv))
      allocate(le(6,klv))
      do i=1,klv
        do j=1,9
           lv(j,i)=0
        enddo
        do j=1,6
           le(j,i)=0
        enddo
      enddo
      allocate(ipposi(10*klv))
      allocate(iqposi(10*klv))
      do i=1,10*klv
         ipposi(i)=0
         iqposi(i)=0
      enddo
      do i=1,klv
         read(3,*) (lv(j,i),j=1,9)
      enddo
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!      do i=1,npatch
!      do j=1,3
!         k1=mod(j-1,3)+1
!         k2=mod(j,3)+1
!         k1=ipat(k1,i)
!         k2=ipat(k2,i)
!         d1=xyz(1,k1)-xyz(1,k2)
!         d2=xyz(2,k1)-xyz(2,k2)
!         d3=xyz(3,k1)-xyz(3,k2)
!         d=sqrt(d1*d1+d2*d2+d3*d3)
!         if (d.ge.0.3) then
!            print*,'the length of the edge is larger than 0.3'
!            print*,i,k1,k2
!         else
!         endif
!       enddo
!       enddo
cccccccccccccccccccccccccccccccccccccccccccccccccccccc
       call sur_vol_coor
     & ( nnode, npatch, klv,
     &   nsnode, nvnode,
     &   ipat, lv,
     &   xyz, xyzs, xyzv,
     &   rp, iqof, iqfo, ip )
       print*,'sur_vol_coor is completed'
c       print*,'nsnode=', nsnode,'  nvnode=',nvnode,'ntnode:',nnode
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc  after this subroutine,nsnode is the number of nodes in surfaces
cc  xyzs store the coordinate of local number of nodes in surfaces,
ccc ipat store the local number of 3 nodes in each facepatch 
cc  and nvnode if the number of nodes in volume, xyzv store the
cc  coordinate of local number of nodes in volume,lv store the 
cc  local number of 4 nodes in each tetrahedron 
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       call sur_edge_label
     & ( nsnode, npatch, nedge, 
     &   ncnode, ncele, ncedge, nbnd,  
     &   ipat, iedge, 
     &   ln, lp, lds, lef,
     &   ip, iq, nc,
     &   xyzs, xyzc1,
     &   rp,iqof,iqfo, labelabc, labelsrc )
       print*,'sur_edge_label is completed'
       print*,'nsnode,nsele,nsedge=',nsnode,npatch,nedge
       print*,'ncnode,ncele,ncedge=',ncnode,ncele,ncedge
       print*,'bnd of PEC and cav =',nbnd
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
cc  after this subroutine, ln store local number of nodes in patch on
cc  cavity surface, lp sotore local number of edges in patch on cavity
cc  surface.lef sort edges  all surface edges.
cc  ncele is the number of patch on cavity surface,ncedge is the number
cc  of edges on cavity surface which include boundary edges,nedge is the
cc  number of all edges on surface.
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
       call vol_edge_label
     & ( klv, ke, klc,kec, keb, kei,
     &   lv, le, lnc, lpc, ldv, nc,
     &   xyzv, xyzc2,
     &   rp, iqof, iqfo, ipw1, ipw2, ipw3, ipw4, ipin,
     &   kefemabc, kefemsrc, labelabc, labelsrc )
       print*,'vol_edge_label is completed'
       print*,'nvnode,nvele,nvedge=',nvnode,klv,ke
       print*,'nvcele,nvcedge     =',klc,kec
       print*,'bnd of PEC and cav =',keb
       print*,'inner PEC edges    =',kei
       call sur_vol_edge
     & ( kec,
     &   ldv, ipw1, lds, ip, ipw2,
     &   rp, iqof, iqfo, rp1, iqof1, iqfo1, 
     &   xyzv, xyzs)
       print*,'sur_vol_edge is completed'

       call fdposi
     & ( mvoladj,
     &   ke, klv, kec, ncele,
     &   lv, le, lnc, lpc, ipposi, iqposi,
     &   rp, iqof, iqfo, ipele,
     &   mvolstore, msurstore)
       print*,'fdposi is completed'
ccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        call write_inform
     & ( nsnode, npatch, nedge,
     &   xyzs,
     &   ipat,iedge,
     &   nvnode, klv, ke, ncnode, ncele, kec, kei, keb,
     &   xyzv,
     &   lv, le, 
     &   lnc, lpc, ipin, ipw2, ipposi, iqposi,
     &   mvolstore, msurstore,runname,
     &   kefemabc, kefemsrc)
        print*,'write_inform is completed'
ccccccccccccccccccccccccrelease memory ccccccccccccccccccccccccccccccccc
110      deallocate(xyz,xyzs,xyzc1,xyzc2,xyzv)
      deallocate(iedge)
      deallocate(ldv)
      deallocate(lds)
      deallocate(ipat)
      deallocate(ln)
      deallocate(lp)
      deallocate(lnc)
      deallocate(lpc)
      deallocate(nc)
      deallocate(iq)
      deallocate(ip)
      deallocate(ipin)
      deallocate(iqof)
      deallocate(iqfo)
      deallocate(iqof1)
      deallocate(iqfo1)
      deallocate(rp)
      deallocate(rp1)
      deallocate(ipw1)
      deallocate(ipw2)
      deallocate(ipw3)
      deallocate(ipw4)
      deallocate(ipele)
      deallocate(lv)
      deallocate(le)
      deallocate(lef)
      deallocate(ipposi)
      deallocate(iqposi)
99    continue
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
        end

